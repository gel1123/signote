<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/nord.min.css" integrity="sha512-igI4zzTHEU3IASS/ojMD7tO6hScqpnEnz41u+xVRNZvZEaF3XaCdre0qZ08frR1hri9+aSNeAXlQz1DS3luvxA==" crossorigin="anonymous" />
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/agate.min.css"> -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/purebasic.min.css" integrity="sha512-5ms/H4/ZHyMU0X3UWrz9cAOOwk/5l5kMf7CAYqjJpGBYLCiX9BhlO3r65PZ0jgitufFP5oa+Ly6RD8dI5gDilQ==" crossorigin="anonymous" /> -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.13.0/beautify.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.13.0/beautify-css.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.13.0/beautify-html.js"></script>

<style>
textarea {
	height: 150px;
	width: 100%;
}
canvas {
	border: 1px solid;
}
.err {
	color: red;
}
#code-canvas1 {
	height: 200px;
	width: 100%
}
video, audio {
	width: 400px;
}
#media-list>li {
	background-color: rgb(240, 240, 240);
}
</style>
<script>
'use strict';

const beautify_opt1 = { indent_size: 4, space_in_empty_paren: true }

const beautify_opt2 = {
  "indent_size": "1",
  "indent_char": "\t",
  "max_preserve_newlines": "5",
  "preserve_newlines": true,
  "keep_array_indentation": false,
  "break_chained_methods": false,
  "indent_scripts": "normal",
  "brace_style": "collapse",
  "space_before_conditional": true,
  "unescape_strings": false,
  "jslint_happy": false,
  "end_with_newline": false,
  "wrap_line_length": "0",
  "indent_inner_html": false,
  "comma_first": false,
  "e4x": false,
  "indent_empty_lines": false
}

document.addEventListener('keydown', (e)=> {
	const ke = document.querySelector('#keyboard-eve');
	const event_name = e.__proto__.toString().match(/[a-z-A-Z]+/g)[1];
	ke.querySelector('li>span').textContent = event_name;
	ke.querySelector('li+li>span').textContent = e.code;
	ke.querySelector('li+li+li>span').textContent = e.key;
})

const test = (self) => {

	document.querySelector('#yourcode').textContent = js_beautify(self.value, beautify_opt1);
	hljs.highlightBlock(document.querySelector('#yourcode'));
	
	try {
		const result = Function(
			'"use strict"; return (' 
			+ self.value
			+ ')'
		)();
		console.log(result);
		document.querySelector('#result>p').textContent = result;
	} catch(e) {
		console.error(e);
		document.querySelector('#result>p').innerHTML = '<div class="err"><strong>▼ 例外をキャッチしました</strong><br>'+e+'</div>';
	}
}
window.onload = () => {
	const event = new Event('input');
	[
		document.querySelector('#code>textarea'),
		document.forms.html_beautify_form.html_beautify_input,
		document.forms.css_beautify_form.css_beautify_input,
		document.querySelector('#code-canvas1'),
		document.querySelector('#webstorage-code1'),
		document.querySelector('#webstorage-code2'),
		document.querySelector('#webstorage-code3'),
		document.querySelector('#webstorage-code4'),
		document.querySelector('#webstorage-code5'),
		document.querySelector('#idb-code1'),
		document.querySelector('#blob-code1'),
		document.querySelector('#ws-code1'),
		document.querySelector('#xhr-code1'),
		document.querySelector('#sp-code1'),
		document.querySelector('#sse-code1'),
		document.querySelector('#other-code1')

	].forEach((elm) => elm.dispatchEvent(new Event('input')));
}

const timeout_status = {};
const mark = (target_id) => {
	if (timeout_status[target_id]) {
		clearTimeout(timeout_status[target_id]);
	}
	const target = document.querySelector(target_id);
	target.style.color = "red";
	target.style.backgroundColor = "yellow";
	timeout_status[target_id] = window.setTimeout(() => {
		target.style.color = "";
		target.style.backgroundColor = "white";
	}, 3000);
};
const mark1 = (target_id, self) => {
	const err_target_list_parent = document.querySelectorAll("#mediaerr *");
	err_target_list_parent.forEach(e => {
		e.style.color = "";
		e.style.backgroundColor = "";
	});
	if (self.error) {
		const err_target_list = document.querySelectorAll(`.mediaerr${self.error.code}`);
		err_target_list.forEach(e => {
			e.style.color = "red";
			e.style.backgroundColor = "yellow";
		});
	}
	const target = document.querySelector(target_id);
	const disptime = target.querySelector(".disptime");
	var now = new Date();
	var now_str = ("0"+now.getHours()).slice(-2) + "時" + ("0"+now.getMinutes()).slice(-2) + "分" + ("0"+now.getSeconds()).slice(-2) + "." + ("00"+now.getMilliseconds()).slice(-3) + "秒";
	disptime.textContent = `${now_str} >> `;
	const parent = document.querySelector("#media-list");
	const first = document.querySelector("#media-list>li");
	parent.insertBefore(target, first);
	mark(target_id);
}
</script>
</head>
<body>
<form id="code">
	<h2>▼ JavaScriptのコードを試し書きできます ※strictモード</h2>
	<textarea oninput="test(this)" spellcheck="false">
(() => {

  var stateObj = { key1: "val1" };
  // history.replaceState(stateObj, "title", "dummy");
  return JSON.stringify(history.state)

})()</textarea>
	<pre><code class="javascript" id="yourcode">
	</code></pre>
</form>
<div id="result">
	<h2>コードの実行結果</h2>
	<p></p>
</div>
<div id="keyboard-eve">
	<h2>発生したキーボードイベント</h2>
	<ul>
		<li>イベントのプロトタイプ名: <span></span> </li>
		<li>codeプロパティ: <span></span></li>
		<li>keyプロパティ: <span></span></li>
	</ul>
</div>

<hr>
<div id="beautify">
	<h2>HTML, CSS整形</h2>
	<form id="html_beautify" name="html_beautify_form">
		<h3>HTML整形</h3>
		<textarea name="html_beautify_input" oninput="
			const target = document.forms.html_beautify_form.querySelector('code');
			target.textContent = html_beautify(this.value, beautify_opt2);
			hljs.highlightBlock(target)
		" spellcheck="false"
		><div><ul><li class="hoge">hoge</li></ul></div></textarea>
		<pre><code class="html"></code></pre>
	</form>

	<form id="css_beautify" name="css_beautify_form">
		<h3>CSS整形</h3>
		<textarea name="css_beautify_input" oninput="
			const target = document.forms.css_beautify_form.querySelector('code');
			target.textContent = css_beautify(this.value, beautify_opt2);
			hljs.highlightBlock(target)
		" spellcheck="false"
		>.hoge { background: red; margin: 0 auto; text-align: center; }</textarea>
		<pre><code class="css"></code></pre>
	</form>
</div>
<hr>
<div id="studying-canvas">
	<h2>canvas試し書き(以下コード編集可能です)</h2>
	<pre><code contenteditable="true"
			oninput="Function(this.textContent)();"
			id="code-canvas1"
			spellcheck="false">
const canvas = document.querySelector("#canvas1");
const context = canvas.getContext("2d");
context.clearRect(0, 0, canvas.width, canvas.height);
context.font = "40px sans-serif";
context.setTransform(
	1,	 	// 1. x軸のスケーリング（拡大率）
	0.5, 	// 2. x軸のスキュー（傾斜率）
	0,	 	// 3. y軸のスキュー（傾斜率）
	1,	 	// 4. y軸のスケーリング（拡大率）
	0,	 	// 5. x軸の移動
	0		// 6. y軸の移動
);
context.fillText("TEST", 50, 50);

const c2 = document.querySelector("#canvas2");
const ctx2 = c2.getContext("2d");

ctx2.clearRect(0, 0, c2.width, c2.height); // 描画領域全体をクリア
ctx2.beginPath(); // パスの開始（サブパスのリセット）
ctx2.strokeStyle = "blue";
ctx2.moveTo(40, 20);
ctx2.lineTo(40, 100);
ctx2.lineTo(100, 100);
ctx2.closePath(); // 始点へと繋がる直線のパスを作成して、パスを終了する
ctx2.stroke();
ctx2.save();
console.log("---- canvas2's context is saved ----")
setInterval(() => {
	ctx2.clearRect(0, 0, c2.width, c2.height);
	setTimeout(() => {
		ctx2.restore();
		ctx2.stroke();
	}, 700)
}, 1000);

</code></pre>
	<div><canvas id="canvas1"></canvas></div>
	<div><canvas id="canvas2"></canvas></div>
</div>
<hr>
<div id="studying-dataurl">
	<h2>dataurl + メディアAPIの利用テスト</h2>
	<h3>dataurlを取得 & 利用するコード</h3>
	<pre><code id="code-dataurl">
const file = document.querySelector("#studying-dataurl>input[type=file]").files[0];
const reader = new FileReader();
reader.addEventListener("load", () => {
	document.querySelector("#result-dataurl").textContent = `${reader.result.substr(0, 100)}...`;
	document.querySelector("#studying-dataurl video").src = reader.result;
	document.querySelector("#studying-dataurl audio").src = reader.result;
	document.querySelector("#studying-dataurl img").src = reader.result;
}, false);
file && reader.readAsDataURL(file);
	</code></pre>
	<h3>以下でファイルを選択すると、dataURLで各メディア要素にファイルが読み込まれます（input type="file"）</h3>
	<input type="file" onchange="
		Function(document
				.querySelector('#code-dataurl')
				.textContent)()">
	<pre><code id="result-dataurl"></code></pre>
	<div>
		<h3>video要素（dataurlが動画ならここで再生できます）</h3>
		<video controls
			   onplay="mark1('#media-onplay', this)"
			   onplaying="mark1('#media-onplaying', this)"
			   ontimeupdate="mark1('#media-ontimeupdate', this)"
			   onpause="mark1('#media-onpause', this)"
			   onwaiting="mark1('#media-onwaiting', this)"
			   onstalled="mark1('#media-onstalled', this)"
			   onended="mark1('#media-onended', this)"
			   onerror="mark1('#media-onerror', this)"
			   onabort="mark1('#media-onabort', this)"
			   onloadstart="mark1('#media-onloadstart', this)"
			   onprogress="mark1('#media-onprogress', this)"
			   onloadeddata="mark1('#media-onloadeddata', this)">
		</video>
	</div>
	<div>
		<h3>audio要素（dataurlが音声ならここで再生できます）</h3>
		<audio controls
			   onplay="mark1('#media-onplay', this)"
			   onplaying="mark1('#media-onplaying', this)"
			   ontimeupdate="mark1('#media-ontimeupdate', this)"
			   onpause="mark1('#media-onpause', this)"
			   onwaiting="mark1('#media-onwaiting', this)"
			   onstalled="mark1('#media-onstalled', this)"
			   onended="mark1('#media-onended', this)"
			   onerror="mark1('#media-onerror', this)"
			   onabort="mark1('#media-onabort', this)"
			   onloadstart="mark1('#media-onloadstart', this)"
			   onprogress="mark1('#media-onprogress', this)"
			   onloadeddata="mark1('#media-onloadeddata', this)">
		</audio>
	</div>
	<div>
		<h3>video, audio要素（HTMLMediaElement）に共通のプロパティ等</h3>
		<h4>イベントハンドラ（メディアを再生すると、イベント発火タイミングを可視化できます）</h4>
		<ol id="media-list">
			<li id="media-onplay"><span class="disptime"></span>onplay<span class="des">：再生実行</span></li>
			<li id="media-onplaying"><span class="disptime"></span>onplaying<span class="des">：再生準備完了</span></li>
			<li id="media-ontimeupdate"><span class="disptime"></span>ontimeupdate<span class="des">：現在の再生時間が更新</span></li>
			<li id="media-onpause"><span class="disptime"></span>onpause<span class="des">：再生停止</span></li>
			<li id="media-onwaiting"><span class="disptime"></span>onwaiting<span class="des">：一時的なデータ不足による停止</span></li>
			<li id="media-onstalled"><span class="disptime"></span>onstalled<span class="des">：予期しないデータ取得失敗</span></li>
			<li id="media-onended"><span class="disptime"></span>onended<span class="des">：再生終了</span></li>
			<li id="media-onerror"><span class="disptime"></span>onerror<span class="des">：読み込み中エラー</span></li>
			<li id="media-onabort"><span class="disptime"></span>onabort<span class="des">：読み込み中断</span></li>
			<li id="media-onloadstart"><span class="disptime"></span>onloadstart<span class="des">：読み込み開始</span></li>
			<li id="media-onprogress"><span class="disptime"></span>onprogress<span class="des">：読み込み中</span></li>
			<li id="media-onloadeddata"><span class="disptime"></span>onloadeddata<span class="des">：読み込み完了</span></li>
		</ol>
		<h4>エラーコード</h4>
		<dl id="mediaerr">
			<dt class="mediaerr1"><b>MEDIA_ERR_ABORTED</b></dt>
			<dd class="mediaerr1">エラーコード "1"。ユーザの要求によるリソースの取得中止</dd>
			<dt class="mediaerr2"><b>MEDIA_ERR_NETWORK</b></dt>
			<dd class="mediaerr2">エラーコード "2"。ネットワークエラーによるリソース取得失敗</dd>
			<dt class="mediaerr3"><b>MEDIA_ERR_DECODE</b></dt>
			<dd class="mediaerr3">エラーコード "3"。リソース取得後のでコード失敗</dd>
			<dt class="mediaerr4"><b>MEDIA_ERR_SRC_NOT_SUPPORTED</b></dt>
			<dd class="mediaerr4">エラーコード "4"。メディアタイプ非対応</dd>
		</dl>
	</div>
	<div>
		<h3>img要素（dataurlが画像ならここに表示されます）</h3>
		<img alt="画像ファイル未取得"></img>
	</div>
</div>
<hr>
<div id="studying-webstorage">
	<h2>Web Storageについて学習</h2>
	<h3>localStorageの使い方</h3>
	<h4>データの追加</h4>
	<pre><code contenteditable="true"
		oninput="Function(this.textContent)();"
		id="webstorage-code1" spellcheck="false">
localStorage.setItem("hoge", 1);
localStorage.setItem("fuge", 2);
localStorage.setItem("last_access", new Date());
document.querySelector("#storagecode-result1").textContent = JSON.stringify(localStorage, null, "    ");
	</code></pre>
	<pre><code>// 実行結果<br><span id="storagecode-result1"></span></code></pre>
	
	
	<h4>データの取得（値とキー）</h4>
	<pre><code contenteditable="true"
		oninput="Function(this.textContent)();"
		id="webstorage-code2" spellcheck="false">
const result = {
	"getItem('last_access')": localStorage.getItem("last_access"), // 値の取得（左記のほか、直接プロパティにアクセスすることも可能だが非推奨）
	"key(0)": localStorage.key(0), // キーの取得 ※順序は保障されない（ユーザエージェント依存）
	"key(1)": localStorage.key(1), // キーの取得 ※順序は保障されない（ユーザエージェント依存）
	"key(2)": localStorage.key(2) //  キーの取得 ※順序は保障されない（ユーザエージェント依存）
}
document.querySelector("#storagecode-result2").textContent = JSON.stringify(result, null, "    ");
	</code></pre>
	<pre><code>// 実行結果<br><span id="storagecode-result2"></span></code></pre>
	
	
	<h4>データの削除</h4>
	<pre><code contenteditable="true"
		oninput="Function(this.textContent)();"
		id="webstorage-code3" spellcheck="false">
localStorage.removeItem("last_access");
document.querySelector("#storagecode-result3").textContent = JSON.stringify(localStorage, null, "    ");
	</code></pre>
	<pre><code>// 実行結果<br><span id="storagecode-result3"></span></code></pre>
	
	
	<h4>当該オリジンの全データ削除</h4>
	<pre><code contenteditable="true"
		oninput="Function(this.textContent)();"
		id="webstorage-code4" spellcheck="false">
localStorage.clear();
document.querySelector("#storagecode-result4").textContent = JSON.stringify(localStorage, null, "    ");
	</code></pre>
	<pre><code>// 実行結果<br><span id="storagecode-result4"></span></code></pre>
	
	
	<h4>storageイベントハンドラの利用</h4>
	<pre><code contenteditable="true"
		oninput="Function(this.textContent)();"
		id="webstorage-code5" spellcheck="false">
// storageイベントハンドラは別タブで同ドメインのストレージ操作があったときに発火する（IE以外）
window.onstorage = e => {
	const info = {
		key: e.key, // 変更されたキー
		oldValue: e.oldValue, // 変更前の値
		newValue: e.newValue, // 変更後の値
		url: e.url, // 変更を実行したURL
		storageArea: e.storageArea // 当該ドメインのストレージの中身（変更後のStorageオブジェクト）
	};
	document.querySelector("#storagecode-result5").textContent = JSON.stringify({
		StorageEvent: info,
		Storage: {
			length: info.storageArea.length
		}
	}, null, "    ");
}
	</code></pre>
	<pre><code>// 実行結果<br><span id="storagecode-result5"></span></code></pre>
	
	
	<h3>sessionStorageの使い方</h3>
	<p>用意されているメソッド等は同じだが、localStorageと違いsessionStorageは、データを同じセッション内でしか保存しない。</p>
	<p>そのため一度ブラウザを閉じればデータは消える。<strong>また新規タブ・ウィンドウでは新しいセッションが作成されるので、別タブ間のstorageイベントハンドラは機能しない。</strong></p>
	<p><small style="color: red"><b>※上記仕様はセッションCookieとは異なっているので注意</b>（ただしiframe内ではどうなるのかは未検証）</small></p>
</div>
<hr>
<div id="studying-idb">
	<h2>indexedDBの使い方</h2>
	<h3>CREATE STORE</h3>
	<pre><code id="idb-code1" contenteditable="true"
		oninput="Function(this.textContent)();" spellcheck="false">
indexedDB.deleteDatabase("DATABASE");

const sel = (s) => document.querySelector(s);
const disp = sel("#idb-result1");
const w = (str) => disp.textContent+=str+"\n";
const customerData = [
	{ ssn: "444-44-4444", name: "Bill", 
		age: 35, email: "bill@company.com" },
	{ ssn: "555-55-5555", name: "Donna", 
		age: 32, email: "donna@home.org" }
];

const r = window.indexedDB.open("DATABASE", 1);
window.db = undefined;
r.onerror = e => {
	w("---- error ----");
	w(e.target.errorCode);
};
r.onsuccess = e => {
	w("---- success ----");
	db = e.target.result;
	const version = db.version;
	w(`---- version is ${version} ----`)
	db.close();
	const second_req = indexedDB.open("DATABASE", parseInt(version)+1);
	second_req.onupgradeneeded = e => {
		w("---- second-onupgradeneeded ----");
		db = e.target.result;
		const names_store = db.createObjectStore("names", { autoIncrement : true });
		names_store.transaction.oncomplete = e => {
			w("---- names_store(transaction-complete) ----");
			const nstore = db.transaction("names", "readwrite").objectStore("names");
			["gel", "sig", "fab"].forEach((name) => nstore.add(name));
		}
	};
	second_req.onsuccess = e => {
		w("---- second-success ----");
		db = e.target.result;
		const version = db.version;
		w(`---- version is ${version} ----`)
	};
	second_req.onerror = e => w("---- second-error ----");
	second_req.onabort = e => w("---- second-abort ----");
};
r.onupgradeneeded = e => {
	w("---- upgradeneeded ----");
	db = e.target.result;
	const store = db.createObjectStore(
		"customers", { keyPath: "ssn" }
	);
	store.createIndex(
		"name", "name", { unique: false }
	);
	store.createIndex(
		"email", "email", { unique: true }
	);
	store.transaction.oncomplete = e => {
		w("---- transaction-complete ----");
		const cstore = db.transaction(
			"customers", "readwrite"
		).objectStore("customers");
		for (var i in customerData) {
			cstore.add(customerData[i]);
		}
	};
	store.transaction.onabort = e => {
		w("---- transaction-abort ----");
		w(e);
	}
	store.transaction.onerror = e => {
		w("---- transaction-error ----");
		w(e);
	}
};
	</code></pre>
	<h3>GET RECORD</h3>
	<pre><code id="idb-code2" contenteditable="true"
		spellcheck=false>
const sel = (s) => document.querySelector(s);
const disp = sel("#idb-result1");
const w = (str) => disp.textContent+=str+"\n";

const transaction = db.transaction(
	["customers"], "readonly"
);
const cstore = transaction.objectStore("customers");
const creq = cstore.get("444-44-4444");
creq.onerror = function(event) {
  w("---- get-error ----");
};
creq.onsuccess = function(event) {
	w("Name for SSN 444-44-4444 is "
		+ creq.result.name);
};
	</code></pre>
	<div><button onclick='try {
		Function(document.querySelector("#idb-code2").textContent)();
	} catch(e) {document.querySelector("#idb-result1").textContent += e+"\n"}'>exec</button></div>
	<h3>GET ALL RECORD</h3>
	<pre><code id="idb-code3" contenteditable="true"
		spellcheck=false>
const sel = (s) => document.querySelector(s);
const disp = sel("#idb-result1");
const w = (str) => disp.textContent+=str+"\n";

const transaction = db.transaction(
	["customers"], "readonly"
);
const cstore = transaction.objectStore("customers");
cstore.openCursor().onsuccess = function(event) {
	const cursor = event.target.result;
	if (cursor) {
		w("Name for SSN " + cursor.key + " is " + cursor.value.name);
		cursor.continue();
	} else {
		w("No more customers");
  }
};

db.transaction("names").objectStore("names").openCursor().onsuccess = e => {
	const cursor = event.target.result;
	if (cursor) {
		w(`${cursor.key}: ${cursor.value}`)
		cursor.continue();
	} else {
		w("No more names");
	}
}
	</code></pre>
	<div><button onclick='try {
		Function(document.querySelector("#idb-code3").textContent)();
	} catch(e) {document.querySelector("#idb-result1").textContent += e+"\n"}'>exec</button></div>
	
	<h3>IndexedDBのコード実行結果（ "CREATE STORE" のみ初期表示時に実行済み。他はボタン押下で実行 ）</h3>
	<pre><code id="idb-result1"></code></pre>
</div>
<hr>
<div id="studying-blob">
	<h2>Blobオブジェクトの使い方</h2>
	<pre><code id="blob-code1" contenteditable="true"
		oninput="Function(this.textContent)();"
		spellcheck="false">
const resources = ["&lt;p&gt;blob&lt;/p&gt;"];
const blob = new Blob(resources, { type : "text/html" });
const url = URL.createObjectURL(blob);
const iframe = document.querySelector("#studying-blob iframe").src = url;

const w = str => document.querySelector("#blob-result1").textContent += str+"\n";
w("---- Blob URL ----");
w(url);
w("---- バイトサイズ ----");
w(blob.size);
w("---- MIMEタイプ ----");
w(blob.type);
	</code></pre>
	<iframe></iframe>
	<pre><code id="blob-result1"></pre></code>
</div>
<div>
	<h2>Web Socket</h2>
	<pre><code id="ws-code1" contenteditable="true"
				 oninput="try { Function(this.textContent)();} catch(e) {document.querySelector('#ws-result1').textContent += e+'\n'}" spellcheck="false">
const w = str => document.querySelector("#ws-result1").textContent += str+"\n";
<strong>// The scheme is ws or wss</strong>
var ws = new WebSocket("<strong>ws://</strong>localhost:8000");
ws.onopen = e => {
	w("---- open ----");
	ws.send("mugi");
};
ws.onclose = e => {
	w("---- close ----");
};
ws.onmessage = e => {
	w("---- message ----");
	w("MESSAGE FROM SERVER -> [ "+e.data+" ]");
	ws.close();
};
ws.onerror = e => {
	w("---- error ----");
};
	</code></pre>
	<pre><code id="ws-result1"></code></pre>
</div>
<div>
	<h2>XMLHttpRequest</h2>
	<pre><code id="xhr-code1" contenteditable="true"
				 oninput="try { Function(this.textContent)();} catch(e) {document.querySelector('#xhr-result1').textContent += e+'\n'}" spellcheck="false">
const w = str => document.querySelector("#xhr-result1").innerHTML += str+"\n";
var client = new XMLHttpRequest();
const STATE = {
	0: "UNSENT (open()メソッドが呼び出し前)",
	1: "OPENED (oepn()メソッドが呼び出し後)",
	2: "HEADERS_RECEIVED (ヘッダ受信後)",
	3: "LOADING (ダウンロード中)",
	4: "DONE (通信完了)"
};

w("---- [before open] ----");
w(`["${client.readyState}"] ${STATE[client.readyState]}`);

client.open("POST", "http://localhost:8080/xhr");
client.setRequestHeader("Content-Type", "text/plain");
w("default timeout is " + client.timeout);
client.timeout = 5000; // millisecond

w("\n---- [before send] ----");
w(`["${client.readyState}"] ${STATE[client.readyState]}`);

client.send("Hi!");
client.onreadystatechange = e => {
	w("\n---- readystatechange (readyStateが変更) ----");
	w(`["${client.readyState}"] ${STATE[client.readyState]}`);

	if (client.readyState == "2") {

		client.responseType = "json";
	}
};
client.onloadstart = e => {
	w("\n---- loadstart (リソースのロード開始) ----");
	console.log(e);
};
client.onprogress = e => {
	w("\n---- progress (処理進行中) ----");
	console.log(e);
};
client.onabort = e => {
	w("\n---- abort (リクエストの中断) ----");
	console.log(e);
};
client.onerror = e => {
	w("\n---- error (エラー発生) ----");
	console.log(e);
};
client.onload = e => {
	w("\n---- load (リソース読み込み完了) ----");
	console.log(e);

	try {
		client.overrideMimeType("text/html");
	} catch (e) {
		w("-- catch exception --");
		w(e);
	}

	try {
		const text = client.responseText;
	} catch(e) {
		w("-- catch exception --");
		w(e);
	}
	try {
		const xml = client.responseXML;
	} catch(e) {
		w("-- catch exception --");
		w(e);
	}

	const info = {
		"getResponseHeader()": client.getResponseHeader("Content-Type"),
		"getAllResponseHeaders()": client.getAllResponseHeaders(),
		status: client.status,
		statusText: client.statusText,
		responseType: client.responseType,
		response: client.response
	};

	w("\n-- HTTP status is "+client.status+" --");
	w(JSON.stringify(info, null, "    "));
};
client.ontimeout = e => {
	w("\n---- timeout (通信タイムアウト) ----");
	console.log(e);
};
client.onloadend = e => {
	w("\n---- loadend (error, abort, loadイベント後に実行) ----");
	console.log(e);
};
	</code></pre>
	<pre><code id="xhr-result1"></code></pre>
</div>
<div id="studying-sp-event">
	<h2>スマホ特有のイベントハンドラ</h2>
	<pre><code id="sp-code1" contenteditable="true"
				 oninput="try { Function(this.textContent)();} catch(e) {document.querySelector('#sp-result1').textContent += e+'\n'}" spellcheck="false">
const w = str => document.querySelector("#sp-result1").innerHTML += str+"\n";
window.addEventListener("orientationchange", e => {
	w("---- orientationchange :: 画面方向の変更が検出されました ----");
	
	// イベント検出直後には横幅の取得が正確ではないので
	// 横幅の取得は処理を遅延させて行うのがベスト
	// 参考にしたURL：http://www.cattlemute.com/2017/12/08/39/
	setTimeout(() => {
		w("-- orientationchange :: ウィンドウの横幅（遅延取得） --");
		w(window.innerWidth);
	}, 100);
	w("-- orientationchange :: ウィンドウの横幅（イベント発生直後） --");
	w(window.innerWidth);
});
window.addEventListener("resize", e => {
	w("---- resize :: 画面方向の変更が検出されました ----");
	setTimeout(() => {
		w("-- resize :: ウィンドウの横幅（遅延取得） --");
		w(window.innerWidth);
	}, 100);
	w("-- resize :: ウィンドウの横幅（イベント発生直後） --");
	w(window.innerWidth);
});
	</code></pre>
	<pre><code id="sp-result1"></code></pre>
</div>
<div id="studying-sse">
	<h2>Server-Sent Events</h2>
	<pre><code id="sse-code1" contenteditable="true"
				 oninput="try { Function(this.textContent)();} catch(e) {document.querySelector('#sse-result1').textContent += e+'\n'}" spellcheck="false">
const w = str => document.querySelector("#sse-result1").innerHTML += str+"\n";
const sse = new EventSource("/sse");
const STATE = {
	0: "[0] CONNECTING",
	1: "[1] OPEN",
	2: "[2] CLOSE"
};
let count = 0;
w(STATE[sse.readyState]);
sse.onopen = e => {
	w("---- open ----");
	console.log("server sent event", e);
	w(STATE[sse.readyState]);
};
sse.onmessage = e => {
	w("---- message ----");
	console.log("server sent event", e);
	w(STATE[sse.readyState]);
	w(e.data);
	count++;
	count > 4 && sse.close();
};
sse.onerror = e => {
	w("---- error ----");
	console.log("server sent event", e);
	w(STATE[sse.readyState]);
};
	</code></pre>
	<pre><code id="sse-result1"></code></pre>
</div>
<div id="studying-other">
	<h2>other</h2>
	<pre><code id="other-code1" contenteditable="true"
				 oninput="try { Function(this.textContent)();} catch(e) {document.querySelector('#other-result1').textContent += e+'\n'}" spellcheck="false">
const w = str => document.querySelector("#other-result1").innerHTML += str+"\n";

const successCB = p => {
	w("----geolocation API----");
	w("-- success--");
	w(p.timestamp);
	const c = p.coords;
	const info = {
		latitude: c.latitude,
		longitude: c.longitude,
		altitude: c.altitude,
		accuracy: c.accuracy,
		altitudeAccuracy: c.altitudeAccuracy,
		heading: c.heading,
		speed: c.speed
	};
	w(JSON.stringify(info, null, '    '))

};
const errorCB= e => {
	w("----geolocation API----");
	w("-- error --");
	w(e.code);
	w(e.message);

};
navigator.geolocation.getCurrentPosition(successCB, errorCB);

w("---- High Resolution Time API  ----");
w(performance.now());

setTimeout(() => {
	w("---- performance.timing ----");
	const ent = Object.entries(JSON.parse(JSON.stringify(performance.timing)));
	ent.sort((p1,p2) => p2[1]-p1[1]);
	w(JSON.stringify(Object.fromEntries(ent), null, "    "));
}, 500);

window.addEventListener("deviceorientation", e => {
	w("---- deviceorientation ----")
	//const info = {
	//	"z軸（alpha. 0~360）": e.alpha,
	//	"x軸（beta. -180~180）": e.beta,
	//	"y軸（gamma. -90~90）": e.gamma
	//}
	//w(JSON.stringify(info, null, "    "));
	document.querySelector("#alpha").textContent = e.alpha;
	document.querySelector("#beta").textContent = e.beta;
	document.querySelector("#gamma").textContent = e.gamma;
});


// ---- study requestAnimationFrame ----
// -- 画面最下部に水色の長方形がスライドしていくアニメーションを作成 --
// ※下記では利用していないが、アニメーションの削除はcancelAnimationFrame(id)を使う
let start = 0;
const target = document.querySelector("#bx");
const step = t => {
	const progress = t - start;
	target.style.left = `${progress/10}px`;
	const iscontinue = ((progress/10)+50) < parseInt(window.innerWidth); //=> is continue animation
	if (iscontinue) {
		window.requestAnimationFrame(step);
	} else {
		setTimeout(() => {
			target.style.left = "0";
			setTimeout(() => {
				window.requestAnimationFrame(reset_step);
			}, 1000);
		}, 1000)
	}

};
const reset_step = t => {
	start = t;
	step(t);
};
window.requestAnimationFrame(step);
	</code></pre>
	<pre><code id="other-result1"></code></pre>
	<div id="do">
		<ul>
			<li>z軸（反時計回りに0~360）<span id="alpha"></span></li>
			<li>x軸（時計回りに-180~180）<span id="beta"></span></li>
			<li>y軸（時計回りに-90~90）<span id="gamma"></span></li>
		</ul>
	</div>
	<div style="position:fixed;bottom:0;left:0;height:10px;width:50px;background:rgba(100,200,255,0.7);" id="bx"></div>
</div>
</body>
</html>

